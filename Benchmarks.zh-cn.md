# Mubai.Snowflake 性能测试汇总

> 运行环境：Windows 11 / .NET 8.0 / BenchmarkDotNet v0.13.10

---

## 1. 单线程 ID 生成性能（IdGenerationBenchmarks）

> 基准方法内部循环生成 N 个 ID，表中给出了：  
> - **整次调用耗时**（Mean）  
> - **折算到单个 ID 的平均耗时**  
> - **推算单线程吞吐量（约值）**

| Benchmark           | 单次调用生成数量 | Mean（整次）       | 单个 ID 平均耗时 | 约吞吐量（单线程）      |
|---------------------|------------------|--------------------|------------------|-------------------------|
| GenerateSingleId    | 1                | 241.5 ns           | 241.5 ns         | ≈ 4.14 M ID/s           |
| Generate1000Ids     | 1,000            | 243,896.0 ns       | 243.9 ns         | ≈ 4.10 M ID/s           |
| Generate10000Ids    | 10,000           | 2,437,215.1 ns     | 243.7 ns         | ≈ 4.10 M ID/s           |
| Generate100000Ids   | 100,000          | 24,403,598.3 ns    | 244.0 ns         | ≈ 4.10 M ID/s           |

- 单线程下，**每个 ID 大约 244 ns** 左右（0.244 μs），不同批量规模下非常稳定。
- 对应吞吐量约 **4.1M ID/s / 线程**，和后面的吞吐量测试结果基本一致。

---

## 2. 多线程并发生成性能（ConcurrentIdGenerationBenchmarks）

> 这里的基准是在同一进程内启动多线程并发生成一批 ID，测量整次调用耗时。  
> 具体单次调用内部生成的总 ID 数量，请以基准项目代码为准。

| Benchmark              | 线程数 | Mean（整次调用） | Gen0    | Gen1    | Gen2    | Allocated |
|------------------------|--------|------------------|--------:|--------:|--------:|----------:|
| GenerateIds_4Threads   | 4      | 9.762 ms         | 46.8750 | 46.8750 | 31.2500 | 1 MB      |
| GenerateIds_8Threads   | 8      | 20.357 ms        | 93.7500 | 62.5000 | 62.5000 | 2 MB      |
| GenerateIds_16Threads  | 16     | 39.928 ms        | 230.7692| 230.7692|153.8462 | 4 MB      |

- 随线程数增加，**总耗时近似线性放大**，说明锁竞争和 GC 压力按预期上升。
- 每次 Benchmark 调用的内存分配量随线程数成比例增加，最大也就 4 MB 左右，仍然比较健康。

---

## 3. ID 解码性能测试（IdDecodingBenchmarks）

> 这一组基准用于评估 **解码雪花 ID** 的开销：  
> 单字段解码（时间戳 / WorkerId / 序列号）、全字段解码、批量解码。

### 3.1 单个 ID 解码

| Benchmark        | 功能                  | Mean（整次） | 单个 ID 平均耗时 | 约吞吐量          |
|------------------|-----------------------|--------------|------------------|-------------------|
| DecodeTimestamp  | 解码时间戳            | 3.2194 ns    | 3.22 ns          | ≈ 3.11 亿 ID/s    |
| DecodeWorkerId   | 解码 WorkerId         | 0.3065 ns    | 0.31 ns          | ≈ 32.63 亿 ID/s   |
| DecodeSequence   | 解码序列号            | 0.4583 ns    | 0.46 ns          | ≈ 21.82 亿 ID/s   |
| DecodeAllFields  | 一次解出全部字段      | 3.6209 ns    | 3.62 ns          | ≈ 2.76 亿 ID/s    |

> 这里的「吞吐量」是按 `1e9 / 平均耗时` 推算出来的理论数值，主要用于量级参考。

### 3.2 批量解码

| Benchmark       | 单次调用解码数量 | Mean（整次）   | 折算单个 ID 耗时 | 约吞吐量        |
|-----------------|------------------|----------------|------------------|-----------------|
| Decode10000Ids  | 10,000           | 37,079.3452 ns | 3.71 ns          | ≈ 2.70 亿 ID/s  |

- 相比 ID 生成（~244 ns），**解码开销要小两个数量级**，基本可以认为“几乎不要钱”。
- 对日志分析 / 运维工具非常友好，可以放心大量解码 ID 做排查。

---

## 4. 不同配置下的性能对比（ConfigurationBenchmarks）

> 评估“获取默认配置 / 自定义配置”的性能开销，确认配置这块不会成为瓶颈。

| Benchmark             | 场景           | Mean      | Allocated |
|-----------------------|----------------|-----------|----------:|
| DefaultConfiguration  | 默认配置       | 241.2 ns  | -         |
| CustomConfiguration   | 自定义配置     | 241.2 ns  | -         |

- 不管是默认还是自定义配置，**获取配置对象的开销都是 240 ns 级别**，对整体系统来说可以认为是零成本。
- 推荐做法：在应用启动时**一次性注册单例生成器和解码器**，运行期间不用再关心配置开销。

---

## 5. 高并发场景性能测试（HighConcurrencyBenchmarks）

> 这一组测试主要用于验证高冲突场景下的**稳定性和内存占用**，而不是精确吞吐量。  
> 每个基准运行大约 25 秒，在持续强并发 / 高冲突下观察行为。

| Benchmark                 | 线程数 | Mean（运行时长） | 内存分配（约） |
|--------------------------|--------|------------------|---------------:|
| HighContention_20Threads | 20     | 25.00 s          | 2.51 MB        |
| HighContention_50Threads | 50     | 25.00 s          | 1.57 MB        |

- 在 20 和 50 线程高竞争压力下，测试可以**稳定跑满整个 25 秒** 的周期，没有异常退出或极端抖动。
- 内存分配维持在 1.5–2.5 MB 左右，说明在长时间高并发场景中不会出现明显的内存泄漏或爆量。

---

## 6. 生成 + 解码综合性能测试（GenerateAndDecodeBenchmarks）

> 这个基准把“生成 ID + 立即解码”打包在一起，模拟完整链路的性能。  
> 适合用来回答一句话：**“从生成 ID 到解析出时间和 WorkerId，一整套要花多少时间？”**

| Benchmark               | 单次调用处理 ID 数 | Mean（整次） | 折算单个 ID 耗时 | 约吞吐量（单线程） |
|-------------------------|--------------------|-------------:|------------------|--------------------|
| GenerateAndDecode_1000  | 1,000              | 243.9 μs     | 243.9 ns         | ≈ 4.10 M ID/s      |
| GenerateAndDecode_10000 | 10,000             | 2,437.5 μs   | 243.75 ns        | ≈ 4.10 M ID/s      |

- 「生成 + 解码一整套」的平均耗时，和“单纯生成”非常接近：**约 244 ns / ID**。
- 自己写运维工具时，可以放心在生成 ID 的同时顺手解码，不用担心性能问题。

---

## 7. 吞吐量测试：每秒生成 ID 数量（ThroughputBenchmarks）

> 这一组是最直观的吞吐测试：单线程一次性生成 100 万 / 1,000 万 / 1 亿个 ID，  
> 然后用总时长推算 **每秒能发多少个 ID**。

| Benchmark              | 单次调用生成数量 | Mean（整次） | 折算吞吐量（约值）     |
|------------------------|------------------|-------------:|------------------------|
| Throughput_1Million    | 1,000,000        | 243.9 ms     | ≈ 4.10 M ID/s          |
| Throughput_10Million   | 10,000,000       | 2,440.8 ms   | ≈ 4.10 M ID/s          |
| Throughput_100Million  | 100,000,000      | 24,413.7 ms  | ≈ 4.10 M ID/s          |

> 计算方式示例：  
> `1,000,000 / (243.9 ms / 1000) ≈ 4,100,041 ID/s`

- 单线程吞吐量在不同规模下都稳定在 **约 4.1M ID/s**；
- 结合多线程并发测试，可以预期在多核机器上，通过多线程/多进程扩展，整体 ID 服务可以轻松支撑绝大多数中大型业务的需求。

---

## 8. 小结

- **生成性能**：单线程约 244 ns / ID，吞吐 ~4.1M ID/s；  
- **解码性能**：单个字段解码在 1–4 ns 级别，吞吐可达数亿 ID/s；  
- **配置 & 初始化**：240 ns 级别，可视为零开销；  
- **高并发稳定性**：在 20 / 50 线程高冲突场景下，可稳定跑满 25 秒测试周期，无异常；  
- **综合链路**：生成 + 解码整套下来仍然维持在 ~244 ns / ID 的量级。
